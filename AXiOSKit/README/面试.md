# KVO
```
KVO
        当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。
        派生类在被重写的 setter 方法中实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。
        同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源。
```  

# kvc
```
        KVC主要通过isa来实现其内部查找定位的. 默认的实现方法由NSOject提供isa指针, 如其名称所指,(就是is a kind of的意思), 指向分发表对象的类. 因为对象的方法和属性成员变量都是存储在类对象中对象使用KVC的时候通过isa找到类对象进而去属性列表查找该属性。。
        
                具体主要分为三大步
        第一步寻找该属性有没有setsetter方法有就直接赋值
        第二步寻找有没有该属性带下划线的成员属性有就直接赋值
        第三步寻找有没有该属性的成员属性有就直接赋值
        举个e.g: 
        [object setValue:@"13123" forKey:@"uuid"];
        
        就会被编译器处理成:
        // 首先找到对应sel
        SEL sel = sel_get_ uuid("setValue:forKey:");
        // 根据object->isa找到sel对应的IMP实现指针
        IMP method = objc_msg_lookup (object->isa,sel);
        // 调用指针完成KVC赋值
        method(object, sel, @"13123", @"uuid");
```

# 多个分类重名时，方法的调用顺序
```
Xcode中的Build Phases->Compile Soures 优先调用分类方法,多个分类, 最后位置的,假如住主类最后,也不会调动主类,还是调用最后的分类
```
